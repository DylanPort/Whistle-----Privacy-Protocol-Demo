/**
 * WHISTLE PROTOCOL - Verification Key Converter for Solana
 * 
 * Converts snarkjs verification keys to Rust byte arrays for the Solana program.
 * 
 * The output format is compatible with the groth16_solana library which requires:
 * - Big-endian byte encoding
 * - Swapped G2 point coordinates (for Solana's alt_bn128 syscalls)
 * 
 * Usage:
 *   node scripts/convert-vk-solana.js [circuit-name]
 * 
 * Output:
 *   build/production/{circuit}/vk_solana.rs
 */

const fs = require('fs');
const path = require('path');

const BUILD_DIR = path.join(__dirname, '..', 'build', 'production');

const CIRCUITS = ['withdraw_merkle', 'unshield_change', 'private_transfer'];

/**
 * Convert decimal string to big-endian bytes
 */
function decimalToBytes(decimalStr, byteLength) {
    let n = BigInt(decimalStr);
    const bytes = [];
    for (let i = 0; i < byteLength; i++) {
        bytes.unshift(Number(n & 0xFFn));
        n >>= 8n;
    }
    return bytes;
}

/**
 * Format bytes as Rust hex array
 */
function formatRustBytes(bytes, indent = '    ') {
    const lines = [];
    for (let i = 0; i < bytes.length; i += 16) {
        const chunk = bytes.slice(i, i + 16);
        const hexStr = chunk.map(b => `0x${b.toString(16).padStart(2, '0')}`).join(', ');
        lines.push(`${indent}${hexStr},`);
    }
    return lines.join('\n');
}

/**
 * Convert G1 point [x, y] to 64 bytes (big-endian)
 */
function g1ToBytes(point) {
    const xBytes = decimalToBytes(point[0], 32);
    const yBytes = decimalToBytes(point[1], 32);
    return [...xBytes, ...yBytes];
}

/**
 * Convert G2 point [[x1, x0], [y1, y0]] to 128 bytes (big-endian, swapped for Solana)
 * 
 * Solana's alt_bn128 expects G2 coordinates in this order:
 * [x1, x0, y1, y0] where each is 32 bytes big-endian
 * 
 * snarkjs outputs: [[x0, x1], [y0, y1]]
 * We need to swap within pairs: [[x1, x0], [y1, y0]]
 */
function g2ToBytes(point) {
    // snarkjs format: [[x0, x1], [y0, y1]]
    // Solana format:  [x1, x0, y1, y0] (swapped within pairs)
    const x0Bytes = decimalToBytes(point[0][0], 32);
    const x1Bytes = decimalToBytes(point[0][1], 32);
    const y0Bytes = decimalToBytes(point[1][0], 32);
    const y1Bytes = decimalToBytes(point[1][1], 32);
    
    // Swap: x1 first, then x0, y1 first, then y0
    return [...x1Bytes, ...x0Bytes, ...y1Bytes, ...y0Bytes];
}

/**
 * Generate Rust code for a verification key
 */
function generateRustCode(vk, circuitName) {
    const numPublicInputs = vk.IC.length - 1;
    
    // Convert all points
    const alphaG1 = g1ToBytes(vk.vk_alpha_1);
    const betaG2 = g2ToBytes(vk.vk_beta_2);
    const gammaG2 = g2ToBytes(vk.vk_gamma_2);
    const deltaG2 = g2ToBytes(vk.vk_delta_2);
    
    const icPoints = vk.IC.map(ic => g1ToBytes(ic));

    // Generate Rust code
    const funcName = circuitName.replace(/-/g, '_');
    
    let code = `// VERIFICATION KEY FOR ${circuitName.toUpperCase()}
// Generated by convert-vk-solana.js
// 
// Format: Big-endian bytes with swapped G2 coordinates for Solana alt_bn128

use groth16_solana::groth16::Groth16Verifyingkey;

pub const ${funcName.toUpperCase()}_NUM_PUBLIC_INPUTS: usize = ${numPublicInputs};

pub const ${funcName.toUpperCase()}_VK_ALPHA_G1: [u8; 64] = [
${formatRustBytes(alphaG1)}
];

pub const ${funcName.toUpperCase()}_VK_BETA_G2: [u8; 128] = [
${formatRustBytes(betaG2)}
];

pub const ${funcName.toUpperCase()}_VK_GAMMA_G2: [u8; 128] = [
${formatRustBytes(gammaG2)}
];

pub const ${funcName.toUpperCase()}_VK_DELTA_G2: [u8; 128] = [
${formatRustBytes(deltaG2)}
];

`;

    // Add IC points
    icPoints.forEach((ic, i) => {
        code += `pub const ${funcName.toUpperCase()}_IC_${i}: [u8; 64] = [
${formatRustBytes(ic)}
];

`;
    });

    // Add getter function
    code += `pub fn get_${funcName}_vk() -> Groth16Verifyingkey<'static> {
    static VK_IC: [[u8; 64]; ${icPoints.length}] = [
        ${icPoints.map((_, i) => `${funcName.toUpperCase()}_IC_${i}`).join(',\n        ')}
    ];
    
    Groth16Verifyingkey {
        nr_pubinputs: ${funcName.toUpperCase()}_NUM_PUBLIC_INPUTS,
        vk_alpha_g1: ${funcName.toUpperCase()}_VK_ALPHA_G1,
        vk_beta_g2: ${funcName.toUpperCase()}_VK_BETA_G2,
        vk_gamme_g2: ${funcName.toUpperCase()}_VK_GAMMA_G2,
        vk_delta_g2: ${funcName.toUpperCase()}_VK_DELTA_G2,
        vk_ic: &VK_IC,
    }
}
`;

    return code;
}

function convertCircuit(circuitName) {
    console.log(`\nConverting verification key for: ${circuitName}`);
    
    const vkPath = path.join(BUILD_DIR, circuitName, `${circuitName}_vk.json`);
    
    if (!fs.existsSync(vkPath)) {
        console.error(`❌ Verification key not found: ${vkPath}`);
        console.error('   Run trusted setup first: node scripts/trusted-setup.js');
        return false;
    }

    try {
        const vk = JSON.parse(fs.readFileSync(vkPath, 'utf-8'));
        const rustCode = generateRustCode(vk, circuitName);
        
        const outputPath = path.join(BUILD_DIR, circuitName, 'vk_solana.rs');
        fs.writeFileSync(outputPath, rustCode);
        
        console.log(`✅ Generated: ${outputPath}`);
        console.log(`   Public inputs: ${vk.IC.length - 1}`);
        
        return true;
    } catch (error) {
        console.error(`❌ Failed to convert ${circuitName}:`);
        console.error(error.message);
        return false;
    }
}

function generateCombinedModule() {
    console.log('\nGenerating combined groth16_vk.rs...');
    
    let combinedCode = `// WHISTLE PROTOCOL - PRODUCTION VERIFICATION KEYS
// Generated by convert-vk-solana.js
//
// Contains verification keys for all production circuits:
// - withdraw_merkle: Full withdrawal with Merkle proof
// - unshield_change: Withdrawal with change re-shielding
// - private_transfer: Shielded balance transfers
//
// To use in your program, copy this file to your program's src directory
// and update lib.rs to import the appropriate verification key.

use anchor_lang::prelude::*;
use groth16_solana::groth16::{Groth16Verifier, Groth16Verifyingkey};

`;

    let hasAll = true;
    for (const circuit of CIRCUITS) {
        const vkPath = path.join(BUILD_DIR, circuit, 'vk_solana.rs');
        if (fs.existsSync(vkPath)) {
            const content = fs.readFileSync(vkPath, 'utf-8');
            // Remove the header and use statement from individual files
            const cleaned = content
                .split('\n')
                .filter(line => !line.startsWith('//') && !line.startsWith('use '))
                .join('\n')
                .trim();
            combinedCode += `// ============================================================================\n`;
            combinedCode += `// ${circuit.toUpperCase()}\n`;
            combinedCode += `// ============================================================================\n\n`;
            combinedCode += cleaned + '\n\n';
        } else {
            hasAll = false;
        }
    }

    if (hasAll) {
        const outputPath = path.join(BUILD_DIR, 'groth16_vk.rs');
        fs.writeFileSync(outputPath, combinedCode);
        console.log(`✅ Combined file: ${outputPath}`);
        return true;
    }
    
    return false;
}

function main() {
    console.log('╔════════════════════════════════════════════════════════════╗');
    console.log('║     WHISTLE PROTOCOL - VK Converter for Solana             ║');
    console.log('╚════════════════════════════════════════════════════════════╝');

    const specificCircuit = process.argv[2];
    
    let circuitsToConvert = CIRCUITS;
    if (specificCircuit) {
        if (!CIRCUITS.includes(specificCircuit)) {
            console.error(`\n❌ Unknown circuit: ${specificCircuit}`);
            console.log('Available circuits:', CIRCUITS.join(', '));
            process.exit(1);
        }
        circuitsToConvert = [specificCircuit];
    }

    const results = [];
    for (const circuit of circuitsToConvert) {
        const success = convertCircuit(circuit);
        results.push({ name: circuit, success });
    }

    // Generate combined file if all circuits converted
    if (!specificCircuit) {
        generateCombinedModule();
    }

    // Summary
    console.log('\n' + '='.repeat(60));
    console.log('CONVERSION SUMMARY');
    console.log('='.repeat(60));
    
    let allSuccess = true;
    results.forEach(r => {
        const status = r.success ? '✅' : '❌';
        console.log(`${status} ${r.name}`);
        if (!r.success) allSuccess = false;
    });

    if (allSuccess) {
        console.log('\n✅ All verification keys converted!');
        console.log('\nNext steps:');
        console.log('1. Copy the generated .rs files to your Solana program');
        console.log('2. Update groth16.rs to use the new verification keys');
        console.log('3. Update verification functions in lib.rs');
        console.log('4. Rebuild and redeploy the program');
    }
}

main();
